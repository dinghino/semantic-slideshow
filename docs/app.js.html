<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="App.html">App</a><ul class='methods'><li data-type='method'><a href="App.html#.didUpdate">didUpdate</a></li><li data-type='method'><a href="App.html#.enableEvents">enableEvents</a></li><li data-type='method'><a href="App.html#.fetchEvents">fetchEvents</a></li><li data-type='method'><a href="App.html#.finalizeApp">finalizeApp</a></li><li data-type='method'><a href="App.html#.getOldState">getOldState</a></li><li data-type='method'><a href="App.html#.init">init</a></li><li data-type='method'><a href="App.html#.loadSlideshow">loadSlideshow</a></li><li data-type='method'><a href="App.html#.onStateChange">onStateChange</a></li><li data-type='method'><a href="App.html#.setAboutInfo">setAboutInfo</a></li><li data-type='method'><a href="App.html#.setState">setState</a></li><li data-type='method'><a href="App.html#.slidesReady">slidesReady</a></li><li data-type='method'><a href="App.html#.updateConfig">updateConfig</a></li><li data-type='method'><a href="App.html#.validateSlideshowFolder">validateSlideshowFolder</a></li></ul></li><li><a href="Counter.html">Counter</a><ul class='methods'><li data-type='method'><a href="Counter.html#.set">set</a></li></ul></li><li><a href="Dimmer.html">Dimmer</a><ul class='methods'><li data-type='method'><a href="Dimmer.html#._changeState">_changeState</a></li><li data-type='method'><a href="Dimmer.html#.init">init</a></li><li data-type='method'><a href="Dimmer.html#.set">set</a></li></ul></li><li><a href="Interface.html">Interface</a><ul class='methods'><li data-type='method'><a href="Interface.html#.addEventListeners">addEventListeners</a></li><li data-type='method'><a href="Interface.html#.addKeyPressEvents">addKeyPressEvents</a></li><li data-type='method'><a href="Interface.html#.addNavigationListeners">addNavigationListeners</a></li><li data-type='method'><a href="Interface.html#.disableTransitions">disableTransitions</a></li><li data-type='method'><a href="Interface.html#.enableSemanticModules">enableSemanticModules</a></li><li data-type='method'><a href="Interface.html#.handleKeyPress">handleKeyPress</a></li><li data-type='method'><a href="Interface.html#.init">init</a></li><li data-type='method'><a href="Interface.html#.onToggleButtons">onToggleButtons</a></li><li data-type='method'><a href="Interface.html#.onToggleUI">onToggleUI</a></li><li data-type='method'><a href="Interface.html#.restoreTransitions">restoreTransitions</a></li><li data-type='method'><a href="Interface.html#.updateButtons">updateButtons</a></li><li data-type='method'><a href="Interface.html#.validateKeyPress">validateKeyPress</a></li></ul></li><li><a href="Slides.html">Slides</a><ul class='methods'><li data-type='method'><a href="Slides.html#.animate">animate</a></li><li data-type='method'><a href="Slides.html#.evaluateTransition">evaluateTransition</a></li><li data-type='method'><a href="Slides.html#.go">go</a></li><li data-type='method'><a href="Slides.html#.init">init</a></li><li data-type='method'><a href="Slides.html#.render">render</a></li><li data-type='method'><a href="Slides.html#.updateHash">updateHash</a></li></ul></li><li><a href="STORAGE.html">STORAGE</a><ul class='methods'><li data-type='method'><a href="STORAGE.html#.validate">validate</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#_slideLoader">_slideLoader</a></li><li><a href="global.html#APP_CONFIG_DEF">APP_CONFIG_DEF</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">app.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file HTML Slideshow presenter.
 * This whole app is a style execrise to regain confidence with javascript ES5,
 * jQuery and semantic-ui framework. It's purpose is to have an instrument to
 * create an slideshow using simple &lt;tt>HTML&lt;/tt> pages and &lt;tt>javascript&lt;/tt>
 * configuration files and settings. This can allow a developer to quickly create
 * an insider slideshow to show progress on some code, live while presenting, to
 * have multiple team members create multiple slides that can work together with
 * no issues...
 * The App itself is a central state managed application, that uses
 * &lt;tt>{@link App.setState}&lt;/tt> to modify the current state and triggers, if
 * needed, behaviours into the initialized main components (&lt;tt>namespaces&lt;/tt>)
 * It dynamically loads slideshows and scripts from a specified folder.
 *
 * &lt;h3>Primary hooks for the application&lt;/h3>
 * Even though not needed for standard use, If you need to programmatically access
 * behaviours, moments and triggers of the application in a custom script you can
 * use these hooks to interface with the {@link App} and do stuff conditionally
 *
 * &lt;ul>
 * &lt;li>{@link App.setState} triggers a state update. should be the only interface
 *         								 with {@link App.state} but shouldn't be used anyway&lt;/li>
 * &lt;li>{@link App.didUpdate} called by {@link App.setState} after doing its stuff
 *         								 can be used to hook on state changes and trigger
 *         								 behaviours conditionally&lt;/li>
 * &lt;li>{@link Slides.go} triggers a slide change, both with a direciton or a slide number cx gvt
 */


var I = 0
var INIT_TIME

/**
 * Main application object. Handles events, initialization and general state of
 * the app.
 * This is the primary interface for the user to handle changes in the application
 * using App.setState() method.
 *
 * @version 0.9.4
 * @author Daniele Calcinai
 * @namespace
 */
var App = {
  // author info
  info: {
    author: 'Daniele Calcinai',
    email: 'dinghino@gmail.com',
    gitHub: 'https://github.com/dinghino',
    version: '0.9.4'
  },
  /**
   * Define the array length for App._prevStates
   * @type {Number}
   * @private
   */
  _maxStateHistory: 10,
  /**
   * stores App._maxStateHistory objects, being old App.state
   * @type {Array}
   * @private
   */
  _prevStates: [{ ready: true }],
  /**
   * Default global config for the app that can be overridden while calling
   * {@link App.init}
   * @type {Object}
   * @prop {Boolean} verbose - Log events from the app, including detailed state changes
   * @prop {Boolean} semanticLog - Turn on the semantic-ui default debugger. can't be set after
   *
   */
  config: {
    verbose: false,
    semanticLog: true
  },
  /**
   * Current state of the app. should be handled ONLY with .setState()
   */
  state : {
    /** @property {boolean} UI is toggled */
    buttonShown: false,
    /** @property {boolean} app initialization status */
    initialized: false,
    /** @property {boolean} true if custom events are present and ready */
    events: false,
    /** @property {bool} true if active, false if hidden */
    dimmer: false,
    /** {Number} total number of slides */
    totalSlides: 0,
    /** @property {number} currently shown slide */
    currentSlide: 1,
    /** {number} previously shown slide ~ used and set in transitions */
    prevSlide: undefined,
    /** {number} next slide to show ~ used and set in transitions */
    nextSlide: undefined
  },

  /**
   * Primary API for the application. changes the internal state object.
   * Has different callbacks for default and user definable actions based on
   * state changes
   * @param {object} nextState requested changes in the application
   */
  setState: function (nextState) {
    var verbose = App.config.verbose;
    if(verbose) console.time('this set state took');


    // validation for arguments
    if (typeof nextState !== 'object') {
      throw new Error('new state should be an object!')
    };
    /**
     * Assign oldState and newState objects properties
     */
    var prevState = $.extend(true, {}, App.state),
        /** {object} merge the old state with the new props passed */
        newState = Object.assign(App.state, nextState);

    /** add last state as first of _prevStates */
    App._prevStates.unshift(prevState)

    /** if length of array is > 10, remove oldest one */
    if(App._prevStates.length > App._maxStateHistory) { App._prevStates.pop() }

    /**
     * check the changes in the state and return a diff object
     * {objects} differences between old state and new state
     *                 diff is structured as diff[propName]: {prev, next}
     */
    var diff = App.checkStateDiffs(prevState, newState)
    /** if requested log the state update informations */
    if (verbose) App.__setStateLog(prevState, nextState, diff, newState)

    /**
     * update current state with the new object
     * @private
     */
    App.state = newState


    /** if &lt;diff> is popuplated handle the change */
    if (diff) App.onStateChange(prevState, newState, diff);

    /** call the user defined method */
    App.didUpdate(prevState);
  },

  /**
   * retrieve a state object from the history (_prevStates) or the whole array
   * if no argument is specified
   * @param  {number} idx optional. range from 0 to App._maxStateHistory
   */
  getOldState: function (idx) {
    /** if no idx is passed return the whole array */
    if(typeof idx !== 'number') return App._prevStates;

    /** {Boolean} wether the passed index is a valid OLD App.state  */
    isOldState = typeof idx === 'number' &amp;&amp; 0 >= idx &lt;= App._maxStateHistory;

    if (!isOldState) {
      var err = 'passed index is not valid. values from 0 to '
                + App._maxStateHistory + ' are valid';

      throw new Error(err)
    };

    /** find the requested old state */
    var oldState = App._prevStates[idx]

    /** check if it's an object. if not (undefined) return it */
    if (typeof oldState === 'object') return oldState;

    /** if oldState is not an {object} throw an error just in case */
    throw new Error('requested old state index do not exists yet.')
  },

  /**
   * evaluate the differences between two state objects
   * @private
   * @param  {object} prevState - a previous state of the app
   * @param  {object} nextState - a next state of the app
   * @return {object|Boolean}     if diffs exists return an object containing
   *                                the differences from prevState to nextState
   *                                otherwhise return false
   */
  checkStateDiffs: function (prevState, nextState) {
    var keys    = Object.keys(nextState),
        getDiff = false
        /** log strings */
        changes  = {};

    keys.forEach(function (k, i) {
      /** check for changes in present properties */
      var changed = prevState[k] !== nextState[k];

      if (changed) {
      getDiff = true;
      /** {Object} store changes informations */
      var change  = { previous: prevState[k], next: nextState[k] };

      /** assign newly created object to changes[k] */
      changes[k] = change;
      }
    })
    /** return the objects containing the changes */
    if(getDiff) return changes
    return false
  },

  /**
   * Default behaviour on state changes. triggers app events.
   * should only be used internally and not accessed from the user
   * @param  {object} prevState previous state of the app
   * @param  {object} nextState next state of the app
   * @param  {object} diff      must contains the diffs within the
   *                            &lt;strong>passed&lt;/strong> states
   */
  onStateChange: function (prevState, nextState, diff) {
    /** {array} property changed */
    var changed = Object.keys(diff),
        pS      = prevState,
        nS      = nextState,
        d       = diff;

    /** activate the dimmer if state changed */
    if (d.dimmer) Dimmer.set(nS.dimmer)

    /**
     * if nextSlide changed and is present in nextSlide, render the slides.
     * evaluation of the next slide number is already done. after animating state
     * will get the new current (should be old next), new prev and undefined next
     */
    if (d.nextSlide &amp;&amp; nS.nextSlide) Slides.render()

    if (d.buttonShown) Interface.toggleUI() // TODO: give it a proper method in Interface
  },

  /**
   * similar to react's componentDidUpdate, is called after the app updated
   * its state and the old state is set to into the history
   * @param  {object} prevState App.state before the update
   */
  didUpdate: function (prevState) {
    // user definable function, can be used to trigger stuff
    // if App.state[prop] !== prevState[prop]
  },

  /**
   * be verbose about changes in App.state and go full console!
   * Must be called after the {@link App.setState} completed the update
   * @private
   * @param  {object} oldState  - the immediately previous state of the app
   * @param  {object} nextState - the changes that triggered the state change
   * @param  {object} changes   - a diff object created with {@link App.checkStateDiffs}
   * @param  {object} newState  - the newly created state
   */
  __setStateLog: function (oldState, nextState, changes, newState) {
    var propsChanged = changes ? Object.keys(changes).length : 0,
        now          = new Date().getTime(),
        timestamp    = ((now - INIT_TIME) / 1000).toFixed(3) + 's'

    console.groupCollapsed(
      '[%s][%d] updating state with %d changes:',
      timestamp, I++, propsChanged, nextState)
      console.trace('update callers chain')
      console.groupCollapsed('changes table')
        console.table(changes)
      console.groupEnd()
      console.groupCollapsed('state objects')
        console.log('prev:', oldState)
        console.log('next:', newState)
      console.groupEnd()
    console.timeEnd('this set state took')
    console.groupEnd()

  },

  /**
   * Initialize the whole app, starting sub .init() method, activating event
   * listeners and setting default parameters here and there
   * @param  {object} config configuration object for the app. will merge with {@link App.config}
   */
  init: function (config) {
    /** save the time of the App.init to be used in logs and stuff */
    INIT_TIME = new Date().getTime()
    /** merge custom config for the app. used primarly to toggle debugging */
    if (config) {
      console.info('custom global config detected! merging', config)
      App.config = Object.assign(App.config, config)
    };

    /** enable semantic-ui debugger if verbose is true */
    if (App.config.semanticLog) $.site('enable debug');

    /** add custom app event listeners to objects and DOM */
    App._events()
    /** set the about section content */
    App.setAboutInfo()
    /** initialize the buttons and their events */
    Interface.init()
  },

  /**
   * validate the selected folder before calling App.loadSlideshow()
   * avoiding unwanted initialization
   * @param  {string} folderName folder to validate
   * @param  {func}   success    called if folderName is found
   * @param  {func}   failure    called if foldername is NOT found
   */
  validateSlideshowFolder: function (folderName, onSuccess, onFail) {
    // define the path to the test file
    var test    = folderName + '/1.html',
        verbose = App.config.verbose;

    $.get(test)
    .success(function () {
        if (verbose) console.info(folderName + '/ found! proceeding')
        if (onSuccess) onSuccess();
      })
    .fail(function () {
        if (verbose) console.warn(folderName + '/ NOT found! Check it');
        if (onFail) onFail();
      }
    )
  },

  /**
   * event triggers
   */

  /** load a slideshow with the given total slides and configuration */
  loadSlideshow: function (config) {
    $(App).trigger('app:loadSlides', [config])
  },
  /** update Slides.config object with custom config */
  updateConfig: function (config) {
    $(App).trigger('app:set-slide-config', [config])
  },
  /** get the custom script file from the slideshow folder
   * @param  {string} fileName will be used in a later release,
   *                           allowing custom names for script.js
   */
  fetchEvents: function (fileName) {
    var verbose = App.config.verbose;

    if (!fileName) fileName = 'script'

    if (!Slides.config.getEvents) {
      return App.slidesReady()
    }
    var path = Slides.config.folder + '/' + fileName + '.js'

    $.getScript(path)
    .done(function (script, status) {
      if (verbose) console.info('script found!', status, 'activating.')
      App.enableEvents()
    })
    .fail(function (jqxhr, settings, exception) {
      if (verbose) console.warn(
        'no extra script found in "' + Slides.config.folder + '/"', jqxhr.status
      )
      App.slidesReady()
    });
  },
  /** enable custom events */
  enableEvents: function () { $(App).trigger('app:enable-custom-events') },
  /** finalize the initialization of the slides */
  slidesReady: function () { $(App).trigger('app:slides-ready') },
  /** finalize initialization of the whole app */
  finalizeApp: function () { $(App).trigger('app:finalize-init') },

  /**
   * Adds custom event listeners to {@link App}, created with jQuery.
   * @private
   */
  _events: function () {
    $(App)
    .on('app:set-slide-config', App._onSetConfig)
    .on('app:loadSlides', App._onLoadSlides)
    .on('app:slides-ready', App._onSlideShowReady)
    .on('app:finalize-init', App._onFinalizeInit)
    .on('app:enable-custom-events', App._onEnableEvents)
  },

  /**
   * Internal event handlers that are used to perfom some basic actions like
   * updating the {@link App} config and/or trigger other events to chain them
   * in a proper workflow
   * TODO: create comments for each one of these so it's easier to know what they
   * do. make them if seems the right thing to do.
   * @private
   */
  _onLoadSlides: function (e, config) {
    // initia lizing slideshow
    App.updateConfig(config)
    Slides.init()
  },
  _onSetConfig: function (e, config) {
    // assigning configuration to app
    Slides.config = Object.assign(Slides.config, config)
  },
  _onSlideShowReady: function (e) {
    Interface.updateButtons()
    // if custom events are present in config and not yet executed run that
    // first before finalizing initialization
    if(Slides.config.events &amp;&amp; !App.state.events) {
      App.enableEvents()
      return
    // if no extra events are presents or are already set, finalize init
    } else { App.finalizeApp() };
  },
  _onFinalizeInit: function (e) {
    // if app is already initialized warn the user
    if (App.state.initialized === true) {
      console.warn('initialization called more than once. check it!')
      return
    }

    // set initial state for the buttons.
    // if necessary do stuff to the UI
    Counter.init();
    if (Slides.config.showButtons &amp;&amp; !App.state.initialized) {
      setTimeout(Interface.toggle, 150);
    };

    // remove the dimmer
    setTimeout(function () {
      App.setState({
        dimmer: false,
        initialized: true
      })
    }, 750)

    // call the onEnter event for the first slide after loading
    Slides.onEnter(App.state.currentSlide)
  },
  _onEnableEvents: function (e) {
    console.log('activating events')
    Slides.config.events = window._slidesEvents
    var events = Slides.config.events
    // if events exists and is  function execute.
    // timeout is needed for the DOM creation
    events &amp;&amp; typeof events === 'function' ? setTimeout(events, 50) : null

    // set events as executed
    App.setState({ events: true })
    // run init validation again
    App.slidesReady()
  },

  /**
   * utility methods
   */

  /** get the about info and set them into the page */
  setAboutInfo: function () {
    var info = App.info
    if(!info.email) about.authorEmail.hide()
    if(!info.gitHub) about.authorGitHub.hide()

    about.appVersion.text(info.version)
    about.authorEmail.attr('href', ('mailto:'+ info.email))
    about.authorGitHub.attr('href', info.gitHub)
  },
};

/**
 * Controller for the slideshow. contains Slides.config, passed down on
 * initialization of the slideshow by Slides.init()
 * Secondary API. exposes controls to manage state changes for the slideshow
 * such as Slides.go() to request a change to a slide.
 *
 * @namespace
 */
var Slides = {
  /** {element} DOM Element that will contain our slides */
  container: $slideContainer,

  /** {object} configuration for the application. contains default properties */
  config: {
    /** folder that contains the slides */
    folder: 'slides',

    /** hash string for the browser address. will get the current slide # after */
    hash: 'slide',

    /** default animations for slide transition */
    transition: {
      left: 'fade left',
      right: 'fade right',
    },

    /** {String} used when creating the slides to override semantic-ui */
    defaultSlideStyle: 'display: -webkit-flex!important; display: flex!important',

    /** {bool} if true try to get the custom .js file for the slideshow */
    getEvents: false,

    /** start with button toggled on or off */
    showButtons: true
  },

  /**
   * initialize the slideshow
   */
  init: function () {
    /** INITIALIZATION */

    /** toggle the dimmer to 'show', hiding content loading */
    App.setState({ dimmer: true })
    Slides.addEventListeners()

    /** reset app initialization to false if needed */
    App.state.initialized === true ? App.setState({ initialized: false }) : null;

    /** empty the slide container */
    Slides.container.empty();

    /** START LOADING */
    Slides.getContent()

    /** INITIAL EVENTS */

    /**  listen to key press events */
    Interface.addKeyPressEvents();

    Slides.updateHash();
  },

  addEventListeners: function () {
    $(Slides).on('slides:request-transition', Slides.evaluateTransition)
  },

  _createSlide: function (idx)  {
    var hash = Slides.config.hash;

    return $('&lt;div>', {
      id: hash + idx,
      class: idx > 1 ? 'transition hidden' : 'transition visible',
      style: idx === 1
                ? 'display: -webkit-flex!important; display: flex!important'
                : ''
    })[0]
  },

  getContent: function () {
    if (App.config.verbose) console.log('fetching slides')
    // local config
    var frag        = document.createDocumentFragment(),
        hash        = Slides.config.hash,
        slidesQty   = 1,
        folder      = Slides.config.folder,
        loadStatus  = 'OK',
        i = 0,
        bit;


    /** handle the error from the ajax call in case it fails */
    function handleError (e) {
      if (e.status == 0) {
        return ' Check Your Network.';
      } else if (e.status == 404) {
        console.warn('Seems we loaded the last slide. You have ', slidesQty, 'slides');
      } else if (e.status == 500) {
        return 'Internel Server Error.';
      } else {
        return 'Unknow Error.\n' + e.responseText;
      }
    };

    // fetch function for ajax request with $.get()
    function ajaxCall () {
      if (loadStatus !== 'OK') return;

      var nextSlide = folder + '/' + slidesQty + '.html';
      bit = Slides._createSlide(slidesQty)

      $.get(nextSlide)
      .fail(function (e) {
        --slidesQty
        /** error handling */
        var error = handleError(e)
        if (error) throw new Error(error);

        /**
         * Since fail means that there are no more slides to load,
         * append everything into the dom and continue configuring the slideshow
         */

        /** save slide quantity in App.state */
        App.setState({ totalSlides: slidesQty })

        /** append the fragments to the DOM into this.config.container */
        Slides.container.append(frag)

        /** execute callback function */
        setTimeout(App.fetchEvents, 0);
      })
      .success(function(data, status, xhr) {
        /** create and append the slide to the fragments */
        $(bit).append($(data)[0]);
        frag.appendChild(bit);

        if (status === 'error') loadStatus = status
        ++slidesQty
        ajaxCall()
      })
    };

    /** execute the slides fetching */
    ajaxCall()
  },

  /** render and animate the slides, updating values if necessary */
  render: function () {
    /** execute the animation for the slides */
    setTimeout(Slides.animate, 10)
  },

  /////////////////////
  // EVENT HANDLERS ///
  /////////////////////

  /**
   * evaluate transition if moving to {direction} and store into App.state
   * @param {string} direction the direction to move.
   *                 one of 'next', 'prev', 'first', 'last'
   */
  evaluateTransition: function (e, data) {
    /** local variables */
    var currentSlide = App.state.currentSlide,
        lastSlide    = App.state.totalSlides,
        request      = data;

    /** validate and request transition if typeof data === number */
    if (typeof request === 'number') {
      if (request > 0 &amp;&amp; request &lt;= lastSlide) {
       App.setState({ nextSlide: request })
       return
      }

      if (request &lt; 1) {
        console.warn('requested an invalid slide: #%d. going to first', request)
        App.setState({ nextSlide: 1 })
        return
      }

      if (request > lastSlide) {
        console.warn('requested slide [%d] do not exists. going to last', request)
        App.setState({ nextSlide: lastSlide})
        return
      }
      throw new Error('was trying to go slide %s, but it seems you crashed me.')
    }

    /**
     * update object properties depending on where we are going.
     * if case is no match throw an error | shouldn't happen from UI
     */
    switch (request) {
      case 'next':
        App.setState({ nextSlide: currentSlide + 1 })
        break

      case 'prev':
        App.setState({ nextSlide: currentSlide - 1 })
        break

      case 'first':
        App.setState({ nextSlide: 1 })
        break

      case 'last':
        App.setState({ nextSlide: lastSlide })
        break

      default:
        throw new Error('Error while moving... what did you do? You nasty...')
    }
  },

  /**
   * high level API. tries to move the slides in a direction
   * @param  {string|number} nextSlide one of 'next', 'prev', 'first', 'last'
   *                                   can also be a number to JUMP directly
   *                                   to a slide passing a number.
   */
  go: function (nextSlide) {
    $(Slides).trigger('slides:request-transition', [nextSlide])
  },

  onEnter: function (slide) {
    var events        = Slides.config.events,
        slidesEvents  = {};

    if (events) { slidesEvents = Slides.config.events[slide] };

    if (!slidesEvents) return;
    var fn = slidesEvents.onEnter
    // end the function if event is not present
    if (!fn || typeof fn !== 'function') return

    fn()
  },

  onLeave: function (slide) {
    var events        = Slides.config.events,
        slidesEvents  = {};

    if (events) { slidesEvents = Slides.config.events[slide] };

    if (!slidesEvents) return;
    var fn = slidesEvents.onLeave

    // end the function if event is not present
    if (!fn || typeof fn !== 'function') return

    fn()
  },

  /**
   *  handler for the animation to move the slides
   */
  animate: function (/*nextSlide*/) {
    var prevSlide   = App.state.currentSlide,
        nextSlide   = App.state.nextSlide,
        slides      = Slides.container.children(),
        value       = Slides.translateAmount,
        hash        = Slides.config.hash;
        prev        = '',
        next        = '',
        transition = {
          enter: '',
          leave: ''
        };

    /**
     * Get the dom elements corresponding the slides to animate. also works as
     * validator for the passed values
     */
    if (typeof prevSlide === 'number') prev = $('#'+ hash + prevSlide);
    if (typeof nextSlide === 'number') next = $('#'+ hash + nextSlide);

    if (next.length === 0 || prev.length === 0) {
      throw new Error(
        'Error while trying to animate the slideshow',
        '\nSeems we couldn\'t find the slides to animate')
    }

    /** set the animations to use for the transition */
    if (prevSlide > nextSlide) {
      transition.leave = Slides.config.transition.left
      transition.enter = Slides.config.transition.right
    } else {
      transition.leave = Slides.config.transition.right
      transition.enter = Slides.config.transition.left
    }

    // update DOM
    prev.transition({
      animation: transition.leave,
      // handle the event listeners
      onStart: function () {
        /** disable transition controls to avoid mess */
        Interface.disableTransitions()
        /** call the onLeave method for current slide */
        Slides.onLeave(prevSlide)
      }
    })
    next.transition({
      animation: transition.enter,
      onStart: function () {
        /** activate onEnter for nextSlide slide */
        Slides.onEnter(nextSlide)
      },
      // handle the event listeners
      onComplete: function () {
        Interface.restoreTransitions()
      }
    })

    /** update the state object with the new slides status */
    App.setState({
      currentSlide: nextSlide,
      prevSlide: prevSlide,
      nextSlide: undefined
    })


    /** call update UI with the new state */
    Counter.set()
    Interface.updateButtons()
    Slides.updateHash()
  },

  /**
   *  update the address on the browser
   */
  updateHash: function () {
    var hash  = Slides.config.hash,
        slide = App.state.currentSlide;

    // update the address hash
    location.hash = hash + slide
  }
};

/**
 * Handles the counter for the slide and the slide jumper behaviour
 * @namespace
 */
var Counter = {
  init: function () {
    /** set counter initial state */
    Counter.set()
  },

  /** set the value of the label if present */
  set: function () {
    var current = App.state.currentSlide,
        total   = App.state.totalSlides,
        /** {string}  label text */
        text    = current + ' of ' + total,
        /** {node} DOM element for the label text */
        $label  = $counter.find('.labelText');

    /** update the label value */
    $($label[0]).text(text)
    $jumperInput.val(current)
  },
  toggle: function () { $counter.transition('fly up') }
}

/**
 * handles the page dimmer created in index.html.
 * @namespace
 */
var Dimmer = {
  states: ['show', 'hide'],

  /** triggers */
  set: function (status) { $(Dimmer).trigger('dimmer:set', [status]) },
  toggle: function () { App.setState({ dimmer: !App.state.dimmer }) },
  /** add event listeners */
  init: function () {
    $(Dimmer).on('dimmer:set', { status: status }, Dimmer._changeState)
  },

  /**
   * change the state of the dimmer, showing or hiding it
   * @param  {object} e       event from $.trigger()
   * @param  {bool}   request true show, false hide
   */
  _changeState: function (e, request) {
    /** {string} 'show' or 'hide' depending on true|false */
    var state = request === true ? Dimmer.states[0] : Dimmer.states[1]

    $dimmer.dimmer(state)
  },

};

/**
 * Handles the events for the control buttons rendered on screen
 * @namespace
 */
var Interface = {
  /**
   * initialize the buttons with their events called from Slides.
   */
  init: function () {
    if (App.config.verbose) console.log('initializing interface')

    /** initialize interface with semantic-ui modules */
    Interface.enableSemanticModules()

    /** initialize the dimmer */
    Dimmer.init()

    /** add basic event listeners */
    Interface.addEventListeners()
  },

  /** Activate slideshow UI semantic-ui modules */
  enableSemanticModules: function () {
    /** help popup from [?] button */
    $helpIcon.popup({
      inline: true,
      position: 'top left',
      on: 'click',
      transition: 'vertical flip',
      // close the about section when popup closes
      onHide: function () { $authorAccordion.accordion('close', 0) }
    });

    $($counterLabel).popup({
      on: 'click',
      inline: true
    })

    /** about &amp; contacts accordion */
    $authorAccordion.accordion()
    /** dimmer settings */
    $dimmer.dimmer({
      duration: {
        show: 500,
        hide: 500
      }
    })
  },

  /** basic event listeners for the UI */
  addEventListeners: function () {

    /** call is done in more than one event. shortening */
    function toggleDimmer () {
      App.setState({ dimmer: !App.state.dimmer })
    };

    /** custom events */
    $(Interface).on('interface:toggle', Interface.onToggleUI);
    $(Interface).on('interface:update-btns', Interface.onToggleButtons);

    /** click events for slides buttons */
    Interface.addNavigationListeners();

    /** event for the toggler button */
    $button.toggle.on('click', Interface.toggle);
    /** event for the black screen button */
    $button.black.on('click', Dimmer.toggle);
    /** event handler for the dimmer click */
    $dimmer.on('click', Dimmer.toggle)

    $button.jump.on('click', function () {
      var nextSlide = $jumperInput.val();
      isInvalid = !nextSlide || isNaN(parseInt(nextSlide))
      if (isInvalid) return
      console.log(nextSlide)
      Slides.go(parseInt(nextSlide))
    })

  },

  /** add functionality to the navigational buttons */
  addNavigationListeners: function () {
    $button.first.on('click', function () {
      Slides.go('first')
    });
    $button.prev.on('click', function () {
      Slides.go('prev')
    });
    $button.next.on('click', function () {
      Slides.go('next')
    });
    $button.last.on('click', function () {
      Slides.go('last')
    });
  },

  /** validate a keyCode from a keypress to handle navigation */
  validateKeyPress: function (key) {
    /**
     * keycode shortcuts * legend
     *
     * right:     -> key, presenter right, SPACE
     * left:      &lt;- key, presenter left
     * home:      HOME key
     * end:       END key
     * toggle:    T key
     * blackout:  "." (mark) key, presenter black screen
     */
    if (key === 39 || key === 34 || key === 32) return 'right';
    if (key === 37 || key === 33) return 'left';
    if (key === 36) return 'home';
    if (key === 35) return 'end';
    if (key === 84) return 'toggle';
    if (key === 190) return 'dim';

    return ''
  },

  /** handle a keypress in the page, when listeners are active */
  handleKeyPress: function(e) {
    var key     = Interface.validateKeyPress(e.keyCode),
        onFirst = App.state.currentSlide === 1,
        onLast  = App.state.currentSlide === App.state.totalSlides;

    /** if one of those is true decide what to do */
    switch (key) {
      case 'left':
        e.preventDefault();
        if (onFirst) break;
        Slides.go('prev')
        break

      case 'right':
        e.preventDefault();
        if (onLast) break;
        Slides.go('next')
        break

      case 'home':
        e.preventDefault();
        if(onFirst) break
        Slides.go('first')
        break

      case 'end':
        e.preventDefault();
        if(onLast) break
        Slides.go('last')
        break

      case 'toggle':
        e.preventDefault();
        Interface.toggle();
        break

      case 'dim':
        e.preventDefault()
        App.setState({
          dimmer: !App.state.dimmer
        })

      default:
        break
    }
  },

  /** instantiate event listeners on key press */
  addKeyPressEvents: function () {
    $(document).keydown(Interface.handleKeyPress);
  },

  /** disables the transition event listeners */
  disableTransitions: function () {
    $(document).unbind('keydown', Interface.handleKeyPress)

    $button.first.off('click');
    $button.prev.off('click');
    $button.next.off('click');
    $button.last.off('click');
  },

  /** add or restore the transition event listeners */
  restoreTransitions: function () {
    Interface.addKeyPressEvents()
    Interface.addNavigationListeners()
  },

  /** event triggers */

  updateButtons: function () { $(Interface).trigger('interface:update-btns') },
  toggleUI: function () { $(Interface).trigger('interface:toggle') },

  toggle: function () { App.setState({buttonShown: !App.state.buttonShown }) },

  /** event handlers */

  /**
   * toggle classes from buttons
   */
  onToggleButtons: function () {
    var currentSlide = App.state.currentSlide,
        lastSlide    = App.state.totalSlides,
        allButtons   = $button.wrapper.children(),
        allDisabled  = $(allButtons[0]).is('disabled');

    /**
      * should be true after the next if statement is executed.
      * prevents useless checking if there is just one slide to show
      * and buttons are already disabled.
      * could be deprecated since there is no way onToggleButtons() is called
      * if there is just one slide to show
     */
    if (lastSlide === 1 &amp;&amp; allDisabled) return;

    /**
     * should be true just the first time it runs or never.
     * disables all the buttons if there is just one slide to show
     * and the first one is not disabled
     */
    if (lastSlide === 1 &amp;&amp; !allDisabled) {
      for (var i = 0; i &lt; allButtons.length; i++) {
        var button = $(allButtons[i]);
        button.addClass('disabled');
      };
      return
    };

    /**
     * check current slideshow status and toggle disable class from buttons
     * if and where needed.
     */
    if (currentSlide === 1) {
      $button.first.addClass('disabled');
      $button.prev.addClass('disabled');
    } else {
      $button.first.removeClass('disabled');
      $button.prev.removeClass('disabled');
    };

    if (currentSlide === lastSlide) {
      $button.next.addClass('disabled');
      $button.last.addClass('disabled');
    } else {
      $button.next.removeClass('disabled');
      $button.last.removeClass('disabled');
    };
  },
  /**
   * Toggle the buttons (and count)
   */
  onToggleUI: function () {
    var state = App.state.buttonShown;

    $button.wrapper.transition('fly left');
    Counter.toggle();
  }
};


/**
 * STORAGE SECTION
 *
 * After here you can find temporary unused functions and methods that are
 * not deleted because they will be useful in future updates and functionalities
 * but are not used currently from the app.
 * @namespace
 */
var STORAGE = {
  /**
   * Can validate a @prop {string} &lt;status> using an array of values
   * TODO: Move somewhere. can be used to validate transition selection
   *       &amp; customization, using an array of valid strings.
   *
   * Validate the dimmer transitions. true or an error if validation is falsy
   * @param  {string} status     desired new status to validate. optional
   * @param  {array}  array      Array of valid values to check with
   * @return {bool/error}        true if valid, undefined if not
   *                             will throw an error if not valid
   */
  validate: function (status, validationArray) {
    //  if nothing is passed assume we want to toggle
    if (!status) return true;

    /** validation rules */
    var states        = validationArray,
        isString      = typeof status === 'string',
        /** actual validation of the passed string */
        isValid       = (function () {
          var valid = false
          for (var i = 0; i &lt; states.length; i++) {
            if (status === states[i]) valid = true;
          }
          return valid
        })();

    /** error handling */
    if (status &amp;&amp; !isString) {
      throw new Error('dimmer received an invalid status property somewhere!')
    };

    if (status &amp;&amp; isString &amp;&amp; !isValid) {
      throw new Error('passed status value to Dimmer is not valid. check')
    };

    /** everything is valid. return true */
    if (status &amp;&amp; isString &amp;&amp; isValid) { return true }

    /** in case something went wrong, throws an error to notify */
    throw new Error('Something went wrong while validating')
  }
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu May 12 2016 14:40:19 GMT+0200 (ora legale Europa occidentale) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
